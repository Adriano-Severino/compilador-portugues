use crate::ast;
use crate::lexer::Token;

grammar<'input>();

Caminho: ast::Caminho = {
    <partes:DotSeparated<TIdentificador>> => ast::Caminho { partes },
};

DotSeparated<T>: Vec<T> = {
    <v:T> => vec![v],
    <mut v:DotSeparated<T>> "." <e:T> => {
        v.push(e);
        v
    }
};



pub Arquivo: ast::Programa = {
    <items:ItemPrograma*> => {
        let mut usings = Vec::new();
        let mut namespaces = Vec::new();
        let mut declaracoes = Vec::new();

        for item in items {
            match item {
                ast::ItemPrograma::Usando(u) => usings.push(u),
                ast::ItemPrograma::Namespace(ns) => namespaces.push(ns),
                ast::ItemPrograma::Declaracao(decl) => declaracoes.push(decl),
            }
        }

        ast::Programa { usings, namespaces, declaracoes }
    }
};

ItemPrograma: ast::ItemPrograma = {
    <us:Usando> => ast::ItemPrograma::Usando(us),
    <ns:Namespace> => ast::ItemPrograma::Namespace(ns),
    <decl:Declaracao> => ast::ItemPrograma::Declaracao(decl),
};

// === NAMESPACES ===
Namespace: ast::DeclaracaoNamespace = {
    "espaco" <nome:IdentificadorCompleto> "{" <declaracoes:Declaracao*> "}" => {
        ast::DeclaracaoNamespace { nome, declaracoes }
    }
};

// === USANDO (IMPORTS) ===
Usando: ast::DeclaracaoUsando = {
   "usando" <caminho:IdentificadorCompleto> ";" => {
       ast::DeclaracaoUsando { caminho }
   }
};

// === IDENTIFICADORES ===
IdentificadorCompleto: String = {
    <primeiro:TIdentificador> <resto:("." <TIdentificador>)*> => {
        let mut resultado = primeiro;
        for parte in resto {
            resultado.push('.');
            resultado.push_str(&parte);
        }
        resultado
    }
};

// === IDENTIFICADORES ======================================================
// Nome simples vindo do lexer
#[inline]
IdentificadorSimples: String = { TIdentificador => <> };

// Alias para manter compatibilidade com regras antigas
Identificador: String = {
    <s:IdentificadorSimples> => s,
};

// === DECLARAÇÕES ===
Declaracao: ast::Declaracao = {
    <funcao:DeclaracaoFuncao> => ast::Declaracao::DeclaracaoFuncao(funcao),
    <classe:DeclaracaoClasse> => ast::Declaracao::DeclaracaoClasse(classe),
    <interf:DeclaracaoInterface> => ast::Declaracao::DeclaracaoInterface(interf),
    <en:DeclaracaoEnumeracao> => ast::Declaracao::DeclaracaoEnum(en),
    <cmd:ComandoTopLevel> => ast::Declaracao::Comando(cmd),
};

// === ENUMERAÇÃO ===
DeclaracaoEnumeracao: ast::DeclaracaoEnum = {
    "enumeração" <nome:IdentificadorSimples> "{" <valores:ListaIdentificadoresEnum?> "}" => {
        ast::DeclaracaoEnum { nome, valores: valores.unwrap_or_default() }
    }
};

// === INTERFACE ===
DeclaracaoInterface: ast::DeclaracaoInterface = {
    // Com parâmetros genéricos
    <_macc:ModificadorAcesso?> "interface" <nome:IdentificadorSimples> <generics:GenericParamsDecl> "{" <metodos:AssinaturasMetodoInterface*> "}" => {
        ast::DeclaracaoInterface { nome, generic_params: generics, metodos }
    },
    // Sem parâmetros genéricos
    <_macc:ModificadorAcesso?> "interface" <nome:IdentificadorSimples> "{" <metodos:AssinaturasMetodoInterface*> "}" => {
        ast::DeclaracaoInterface { nome, generic_params: vec![], metodos }
    }
};

AssinaturasMetodoInterface: ast::AssinaturaMetodo = {
    <macc:ModificadorAcesso?> <ret:Tipo> <nome:IdentificadorSimples> "(" <params:InnerParamList> ";" => {
        ast::AssinaturaMetodo { nome, parametros: params, tipo_retorno: if ret == ast::Tipo::Vazio { None } else { Some(ret) }, modificador: macc.unwrap_or(ast::ModificadorAcesso::Publico) }
    }
};

// Listas específicas para evitar conflitos com listas de Tipos
#[inline]
ListaIdentificadoresEnum: Vec<String> = {
    <primeiro:IdentificadorSimples> <rest:("," IdentificadorSimples)*> => {
        let mut v = vec![primeiro];
        v.extend(rest.into_iter().map(|(_, id)| id));
        v
    }
};

// === MODIFICADORES DE ACESSO =============================================
ModificadorAcesso: ast::ModificadorAcesso = {
    "publico"   => ast::ModificadorAcesso::Publico,
    "privado"   => ast::ModificadorAcesso::Privado,
    "protegido" => ast::ModificadorAcesso::Protegido,
};

// === CLASSES ===
DeclaracaoClasse: ast::DeclaracaoClasse = {
    // Com parâmetros genéricos
    <modificador:ModificadorAcesso?> <classe_abstrata:("abstrata")?> <estatica:("estática")?> "classe" <nome_classe:IdentificadorSimples> <generic_params:GenericParamsDecl>
    <lista_cabecalho:(":" <ListaTiposNomeados>)?>
    "{" <membros:MembroClasse*> "}" => {
        let mut campos = Vec::new();
        let mut propriedades = Vec::new();
        let mut metodos = Vec::new();
        let mut construtores = Vec::new();

        for membro in membros {
            match membro {
                ast::MembroClasse::Campo(campo) => campos.push(campo),
                ast::MembroClasse::Propriedade(prop) => propriedades.push(prop),
                ast::MembroClasse::Metodo(metodo) => metodos.push(metodo),
                ast::MembroClasse::Construtor(construtor) => construtores.push(construtor),
            }
        }

        // Determina base e interfaces (apenas nomes por enquanto)
        let mut classe_pai: Option<String> = None;
        let mut interfaces: Vec<String> = Vec::new();
        if let Some(mut lista) = lista_cabecalho {
            if !lista.is_empty() {
                let base_nome = match &lista[0] {
                    ast::Tipo::Classe(n) => n.clone(),
                    _ => unreachable!("Tipo inválido em cabeçalho de classe"),
                };
                classe_pai = Some(base_nome);
                for t in lista.into_iter().skip(1) {
                    let nome_iface = match t {
                        ast::Tipo::Classe(n) => n,
                        _ => unreachable!("Tipo inválido em lista de interfaces"),
                    };
                    interfaces.push(nome_iface);
                }
            }
        }

    ast::DeclaracaoClasse {
            nome: nome_classe,
            classe_pai,
            interfaces,
        generic_params,
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            campos,
            propriedades,
            metodos,
            construtores,
            eh_abstrata: classe_abstrata.is_some(),
            eh_estatica: estatica.is_some(),
        }
    },
    // Sem parâmetros genéricos
    <modificador:ModificadorAcesso?> <classe_abstrata:("abstrata")?> <estatica:("estática")?> "classe" <nome_classe:IdentificadorSimples>
    <lista_cabecalho:(":" <ListaTiposNomeados>)?>
    "{" <membros:MembroClasse*> "}" => {
        let mut campos = Vec::new();
        let mut propriedades = Vec::new();
        let mut metodos = Vec::new();
        let mut construtores = Vec::new();

        for membro in membros {
            match membro {
                ast::MembroClasse::Campo(campo) => campos.push(campo),
                ast::MembroClasse::Propriedade(prop) => propriedades.push(prop),
                ast::MembroClasse::Metodo(metodo) => metodos.push(metodo),
                ast::MembroClasse::Construtor(construtor) => construtores.push(construtor),
            }
        }

        // Determina base e interfaces (apenas nomes por enquanto)
        let mut classe_pai: Option<String> = None;
        let mut interfaces: Vec<String> = Vec::new();
        if let Some(mut lista) = lista_cabecalho {
            if !lista.is_empty() {
                let base_nome = match &lista[0] {
                    ast::Tipo::Classe(n) => n.clone(),
                    _ => unreachable!("Tipo inválido em cabeçalho de classe"),
                };
                classe_pai = Some(base_nome);
                for t in lista.into_iter().skip(1) {
                    let nome_iface = match t {
                        ast::Tipo::Classe(n) => n,
                        _ => unreachable!("Tipo inválido em lista de interfaces"),
                    };
                    interfaces.push(nome_iface);
                }
            }
        }

        ast::DeclaracaoClasse {
            nome: nome_classe,
            classe_pai,
            interfaces,
            generic_params: vec![],
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            campos,
            propriedades,
            metodos,
            construtores,
            eh_abstrata: classe_abstrata.is_some(),
            eh_estatica: estatica.is_some(),
        }
    }
};

MembroClasse: ast::MembroClasse = {
    <c:ConstrutorDecl>      => ast::MembroClasse::Construtor(c),
    <p:PropriedadeClasse>   => ast::MembroClasse::Propriedade(p),
    <f:CampoClasse>         => ast::MembroClasse::Campo(f),
    <m:MetodoClasse>        => ast::MembroClasse::Metodo(m),
};

// === CAMPOS ===
CampoClasse: ast::CampoClasse = {
    // sem valor inicial (não estático)
    <acc:ModificadorAcesso?> <t:Tipo> <id:IdentificadorSimples> ";" => {
        ast::CampoClasse {
            nome: id,
            tipo: t,
            modificador: acc.unwrap_or(ast::ModificadorAcesso::Privado),
            valor_inicial: None,
            eh_estatica: false,
        }
    },

    // com valor inicial (não estático)
    <acc:ModificadorAcesso?> <t:Tipo> <id:IdentificadorSimples> "=" <v:Expressao> ";" => {
        ast::CampoClasse {
            nome: id,
            tipo: t,
            modificador: acc.unwrap_or(ast::ModificadorAcesso::Privado),
            valor_inicial: Some(v),
            eh_estatica: false,
        }
    },

    // sem valor inicial (estático)
    <acc:ModificadorAcesso?> "estática" <t:Tipo> <id:IdentificadorSimples> ";" => {
        ast::CampoClasse {
            nome: id,
            tipo: t,
            modificador: acc.unwrap_or(ast::ModificadorAcesso::Privado),
            valor_inicial: None,
            eh_estatica: true,
        }
    },

    // com valor inicial (estático)
    <acc:ModificadorAcesso?> "estática" <t:Tipo> <id:IdentificadorSimples> "=" <v:Expressao> ";" => {
        ast::CampoClasse {
            nome: id,
            tipo: t,
            modificador: acc.unwrap_or(ast::ModificadorAcesso::Privado),
            valor_inicial: Some(v),
            eh_estatica: true,
        }
    },
};


// === PROPRIEDADES ===

PropriedadeInicializador: ast::Expressao = {
    "=" <e:Expressao> => e
};
PropriedadeClasse: ast::PropriedadeClasse = {
    <modificador:ModificadorAcesso?> <estatica:("estática")?> <tipo:Tipo> <nome:IdentificadorSimples> "{" <acessores:AcessorPropriedade+> "}" => {
        let mut obter = None;
        let mut definir = None;

        for acessor in acessores {
            match acessor {
                (true, modificador_acessor) => obter = Some(ast::AcessorPropriedade {
                    modificador: modificador_acessor,
                    corpo: None
                }),
                (false, modificador_acessor) => definir = Some(ast::AcessorPropriedade {
                    modificador: modificador_acessor,
                    corpo: None
                }),
            }
        }

        ast::PropriedadeClasse {
            nome,
            tipo,
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            obter,
            definir,
            valor_inicial: None,
            eh_estatica: estatica.is_some(),
        }
    }
};

AcessorPropriedade: (bool, Option<ast::ModificadorAcesso>) = {
    <modificador:ModificadorAcesso?> "obter" ";" => (true, modificador),
    <modificador:ModificadorAcesso?> "definir" ";" => (false, modificador),
};
// === FUNÇÕES E MÉTODOS ===
DeclaracaoFuncao: ast::DeclaracaoFuncao = {
    // A. [mod] [estática] função nome (params) { corpo } → retorno = Vazio
    <m:ModificadorAcesso?> <estatica:("estática")?> "função"
    <nome:IdentificadorSimples> "(" <params:InnerParamList> <body:BlocoComando> => {
        ast::DeclaracaoFuncao {
            nome,
            generic_params: vec![],
            parametros: params,
            tipo_retorno: Some(ast::Tipo::Vazio),
            modificador: m.unwrap_or(ast::ModificadorAcesso::Publico),
            corpo: body,
            eh_estatica: estatica.is_some(),
        }
    },
    // B. [mod] [estática] função nome (params) => Tipo { corpo }
    <m:ModificadorAcesso?> <estatica:("estática")?> "função"
    <nome:IdentificadorSimples>
    "(" <params:InnerParamList> "=>" <ret:Tipo> <body:BlocoComando> => {
        ast::DeclaracaoFuncao {
            nome,
            generic_params: vec![],
            parametros: params,
            tipo_retorno: Some(ret),
            modificador: m.unwrap_or(ast::ModificadorAcesso::Publico),
            corpo: body,
            eh_estatica: estatica.is_some(),
        }
    },

    // E. [mod] [estática] função TipoSimples nome<Ts>? (params) { corpo }
    <m:ModificadorAcesso?> <estatica:("estática")?> "função"
    <ret:TipoRetornoSimples> <nome:IdentificadorSimples> <generic_params:GenericParamsDecl?>
    "(" <params:InnerParamList> <body:BlocoComando> => {
        ast::DeclaracaoFuncao {
            nome,
            generic_params: generic_params.unwrap_or_default(),
            parametros: params,
            tipo_retorno: Some(ret),
            modificador: m.unwrap_or(ast::ModificadorAcesso::Publico),
            corpo: body,
            eh_estatica: estatica.is_some(),
        }
    },
};


// Tipo de retorno simples (sem tipo aplicado Nome<...>) para reduzir ambiguidades após "função"
TipoRetornoSimples: ast::Tipo = {
    <base:TipoRetornoBase> <sufs:("[" "]")*> => {
        let mut t = base;
        for _ in sufs { t = ast::Tipo::Lista(Box::new(t)); }
        t
    }
};

TipoRetornoBase: ast::Tipo = {
    "inteiro" => ast::Tipo::Inteiro,
    "texto" => ast::Tipo::Texto,
    "booleano" => ast::Tipo::Booleano,
    "flutuante" => ast::Tipo::Flutuante,
    "duplo" => ast::Tipo::Duplo,
    "decimal" => ast::Tipo::Decimal,
    "vazio" => ast::Tipo::Vazio,
    <nome:TIdentificador> => ast::Tipo::Classe(nome),
};

// — MÉTODO DE INSTÂNCIA ----------------------------------------------------
MetodoClasse: ast::MetodoClasse = {
    // Método com corpo (genéricos opcionais)
    <m:ModificadorAcesso?>            // publico | privado | protegido
    <estatica:("estática")?>
    <abstrato:("abstrata")?>
    <redefinivel:("redefinível")?>
    <sobrescreve:("sobrescreve")?>
    <ret:Tipo>                       // inteiro | texto | Classe ...
    <nome_metodo:IdentificadorSimples>
    <generic_params:GenericParamsDecl?>
    "(" <p:InnerParamList>
    <b:BlocoComando>
        => ast::MetodoClasse {
            nome: nome_metodo.clone(),
            generic_params: generic_params.unwrap_or_default(),
            parametros: p,
            tipo_retorno: if ret == ast::Tipo::Vazio { None } else { Some(ret) },
            modificador: m.unwrap_or(ast::ModificadorAcesso::Publico),
            corpo: b,
            eh_virtual: redefinivel.is_some(),
            eh_override: sobrescreve.is_some(),
            eh_abstrato: abstrato.is_some(),
            eh_estatica: estatica.is_some(),
        },

    // Método abstrato (termina com ';' e exige 'abstrata'; genéricos opcionais)
    <m:ModificadorAcesso?>
    <estatica:("estática")?>
    "abstrata"
    <redefinivel:("redefinível")?>
    <sobrescreve:("sobrescreve")?>
    <ret:Tipo>
    <nome_metodo:IdentificadorSimples>
    <generic_params:GenericParamsDecl?>
    "(" <p:InnerParamList> ";" => ast::MetodoClasse {
        nome: nome_metodo,
        generic_params: generic_params.unwrap_or_default(),
        parametros: p,
        tipo_retorno: if ret == ast::Tipo::Vazio { None } else { Some(ret) },
        modificador: m.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: vec![],
        eh_virtual: redefinivel.is_some(),
        eh_override: sobrescreve.is_some(),
        eh_abstrato: true,
        eh_estatica: estatica.is_some(),
    },
};

/* ------------------------------------------------------------------
   CONSTRUTOR DE CLASSE
   ------------------------------------------------------------------ */
ConstrutorDecl: ast::ConstrutorClasse = {
    <m:ModificadorAcesso?>
    <nome:IdentificadorSimples>
    "(" <p:InnerParamList>
    <chamada_pai:(":" "base" "(" InnerArgList)?>
    <b:BlocoComando>
    => {
        let base_args = if let Some((_, _, _, args)) = chamada_pai {
            Some(args)
        } else {
            None
        };
        ast::ConstrutorClasse {
            parametros: p,
            modificador: m.unwrap_or(ast::ModificadorAcesso::Publico),
            corpo: b,
            chamada_pai: base_args,
            nome_escrito: Some(nome),
        }
    }
};

#[inline]                     // argumentos de chamada
ListaArgumentos: Vec<ast::Expressao> = {
    // primeiro , resto*
    <primeiro:Expressao> <rest:("," Expressao)*> => {
        let mut v = vec![primeiro];
        v.extend(rest.into_iter().map(|(_, e)| e));
        v
    }
};

#[inline]                     // parâmetros de declaração
ListaParametros: Vec<ast::Parametro> = {
    <primeiro:ParametroSimples> <rest:("," ParametroSimples)*> => {
        let mut v = vec![primeiro];
        v.extend(rest.into_iter().map(|(_, p)| p));
        v
    }
};

#[inline]
ParametroSimples: ast::Parametro = {
    // Colocar a forma com '=' primeiro ajuda a resolver shift/reduce em alguns estados
    <tipo:Tipo> <nome:TIdentificador> "=" <valor:ExpressaoAtomo> => {
        ast::Parametro::opcional(nome, tipo, valor)
    },
    <tipo:Tipo> <nome:TIdentificador> => {
        ast::Parametro::obrigatorio(nome, tipo)
    },
};

// Lista de elementos de array
ListaElementosArray: Vec<ast::Expressao> = {
    <primeiro:Expressao> <rest:("," Expressao)*> => {
        let mut v = vec![primeiro];
        v.extend(rest.into_iter().map(|(_, e)| e));
        v
    }
};

// === COMANDOS SE/SENÃO (matched/unmatched) ===
Comando: ast::Comando = {
    <c:ComandoCasado> => c,
    <u:ComandoDescasado> => u,
};

ComandoOutro: ast::Comando = {
    "var" <nome:IdentificadorSimples> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVar(nome, expr)
    },
    <cmd:ComandosBasicos> => cmd,
};

ComandoCasado: ast::Comando = {
    // if-else casado
    "se" "(" <cond:Expressao> ")" <t:ComandoCasado> "senão" <e:ComandoCasado> => {
        ast::Comando::Se(cond, Box::new(t), Some(Box::new(e)))
    },
    // while e for com corpo casado
    "enquanto" "(" <cond:Expressao> ")" <corpo:ComandoCasado> => {
        ast::Comando::Enquanto(cond, Box::new(corpo))
    },
    "para" "(" <init:ForHeaderCmd?> ";" <cond:Expressao?> ";" <incr:ForHeaderCmd?> ")" <corpo:ComandoCasado> => {
        ast::Comando::Para(
            init.map(Box::new),
            cond,
            incr.map(Box::new),
            Box::new(corpo)
        )
    },
    <outro:ComandoOutro> => outro,
};

ComandoDescasado: ast::Comando = {
    // if sem else (o corpo pode ser qualquer Comando)
    "se" "(" <cond:Expressao> ")" <t:Comando> => {
        ast::Comando::Se(cond, Box::new(t), None)
    },
    // if-else onde o 'then' é casado mas o 'else' ainda não está completo
    "se" "(" <cond:Expressao> ")" <t:ComandoCasado> "senão" <e:ComandoDescasado> => {
        ast::Comando::Se(cond, Box::new(t), Some(Box::new(e)))
    },
    // while e for com corpo potencialmente descasado
    "enquanto" "(" <cond:Expressao> ")" <corpo:ComandoDescasado> => {
        ast::Comando::Enquanto(cond, Box::new(corpo))
    },
    "para" "(" <init:ForHeaderCmd?> ";" <cond:Expressao?> ";" <incr:ForHeaderCmd?> ")" <corpo:ComandoDescasado> => {
        ast::Comando::Para(
            init.map(Box::new),
            cond,
            incr.map(Box::new),
            Box::new(corpo)
        )
    },
};

// partes de cabeçalho do 'para' sem consumir ';'
ForHeaderCmd: ast::Comando = {
    "var" <nome:IdentificadorSimples> "=" <expr:Expressao> => {
        ast::Comando::DeclaracaoVar(nome, expr)
    },
    <expr:Expressao> => ast::Comando::Expressao(expr),
};

ComandosBasicos: ast::Comando = {
    // Declarações tipadas (com tipos primitivos específicos para evitar conflito)
    "inteiro" <nome:IdentificadorSimples> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Inteiro, nome, Some(expr))
    },
    "inteiro" <nome:IdentificadorSimples> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Inteiro, nome, None)
    },
    "texto" <nome:IdentificadorSimples> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Texto, nome, Some(expr))
    },
    "texto" <nome:IdentificadorSimples> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Texto, nome, None)
    },
    "booleano" <nome:IdentificadorSimples> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Booleano, nome, Some(expr))
    },
    "booleano" <nome:IdentificadorSimples> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Booleano, nome, None)
    },
    "flutuante" <nome:IdentificadorSimples> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Flutuante, nome, Some(expr))
    },
    "flutuante" <nome:IdentificadorSimples> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Flutuante, nome, None)
    },
    "duplo" <nome:IdentificadorSimples> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Duplo, nome, Some(expr))
    },
    "duplo" <nome:IdentificadorSimples> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Duplo, nome, None)
    },
    "decimal" <nome:IdentificadorSimples> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Decimal, nome, Some(expr))
    },
    "decimal" <nome:IdentificadorSimples> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Decimal, nome, None)
    },

    // qualquer expressão standalone como comando
    <expr:Expressao> ";" => ast::Comando::Expressao(expr),

    // Declaração de classe: NomeClasse nome = expr; ou NomeClasse nome;
    // Isso precisa vir DEPOIS das chamadas de função para não causar conflito
    <tipo_nome:IdentificadorSimples> <var_nome:IdentificadorSimples> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Classe(tipo_nome), var_nome, Some(expr))
    },
    <tipo_nome:IdentificadorSimples> <var_nome:IdentificadorSimples> ";" => {
        ast::Comando::DeclaracaoVariavel(ast::Tipo::Classe(tipo_nome), var_nome, None)
    },

    // obj.propriedade = expr;
    <obj:ExpressaoPostfixa> "." <prop:IdentificadorSimples> "=" <expr:Expressao> ";" => {
        ast::Comando::AtribuirPropriedade(Box::new(obj), prop, expr)
    },

    // nome = expr;
    <nome:IdentificadorSimples> "=" <expr:Expressao> ";" =>
        ast::Comando::Atribuicao(nome, expr),

    "imprima" "(" <expr:Expressao> ")" ";" =>
        ast::Comando::Imprima(expr),

    <bloco:BlocoComando> =>
        ast::Comando::Bloco(bloco),

    "retorne" <expr:Expressao?> ";" =>
        ast::Comando::Retorne(expr),
};

// === TIPOS E IDENTIFICADORES ===
// Tipo com sufixos de array pós-fixados (ex.: inteiro[][], Lista<Texto>[])
Tipo: ast::Tipo = {
    <base:TipoBase> <sufs:("[" "]")*> => {
        let mut t = base;
        for _ in sufs { t = ast::Tipo::Lista(Box::new(t)); }
        t
    }
};

// Componentes básicos de tipo (sem arrays)
TipoBase: ast::Tipo = {
    // Tipos primitivos
    "inteiro" => ast::Tipo::Inteiro,
    "texto" => ast::Tipo::Texto,
    "booleano" => ast::Tipo::Booleano,
    "flutuante" => ast::Tipo::Flutuante,
    "duplo" => ast::Tipo::Duplo,
    "decimal" => ast::Tipo::Decimal,
    "vazio" => ast::Tipo::Vazio,

    // Tipos aplicados Nome<...>
    <t:TipoAplicadoSimples> => t,

    // Tipos customizados simples
    <nome:TIdentificador> => ast::Tipo::Classe(nome),
};

// Tipo de retorno restrito a tipos primitivos e vazio (para desambiguar com genéricos de função)
#[inline]
TipoPrimitivoOuVazio: ast::Tipo = {
    "inteiro" => ast::Tipo::Inteiro,
    "texto" => ast::Tipo::Texto,
    "booleano" => ast::Tipo::Booleano,
    "flutuante" => ast::Tipo::Flutuante,
    "duplo" => ast::Tipo::Duplo,
    "decimal" => ast::Tipo::Decimal,
    "vazio" => ast::Tipo::Vazio,
};

// Tipo aplicado Nome<T1, T2, ...> (exige pelo menos 1 argumento)
#[inline]
TipoAplicadoSimples: ast::Tipo = {
    <nome:TIdentificador> "<" <primeiro:Tipo> <rest:("," Tipo)*> ">" => {
        let mut v = vec![primeiro];
        v.extend(rest.into_iter().map(|(_, t)| t));
        ast::Tipo::Aplicado { nome, args: v }
    }
};

// Lista de tipos (se necessário em outros locais)
#[inline]
ListaTipos: Vec<ast::Tipo> = {
    <primeiro:Tipo> <rest:("," Tipo)*> => {
        let mut v = vec![primeiro];
        v.extend(rest.into_iter().map(|(_, t)| t));
        v
    }
};

// Parâmetros genéricos em contexto de declaração (apenas nomes) - exige pelo menos 1
GenericParamsDecl: Vec<String> = {
    "<" <params:ListaIdentificadoresEnum> ">" => params,
};

// Tipos permitidos em declaração local (incluindo classes)
// === COMANDOS - ✅ ESTRUTURA SIMPLIFICADA ===
ComandoTopLevel: ast::Comando = {
    <cmd:Comando> => cmd,
};

ComandoSimples: ast::Comando = <cmd:Comando> => cmd;


BlocoComando: Vec<ast::Comando> = {
    "{" <comandos:Comando*> "}" => comandos
};

// Lista para cabeçalho de classe: Base e interfaces – apenas nomes simples por enquanto
#[inline]
ListaTiposNomeados: Vec<ast::Tipo> = {
    <primeiro:TipoNomeadoHeader> <rest:("," TipoNomeadoHeader)*> => {
        let mut v = vec![primeiro];
        v.extend(rest.into_iter().map(|(_, t)| t));
        v
    }
};

// Tipo nomeado usado no cabeçalho (sem primitivos e sem genéricos aplicados por enquanto)
TipoNomeadoHeader: ast::Tipo = {
    <nome:TIdentificador> => ast::Tipo::Classe(nome),
};

// === EXPRESSÕES - ✅ HIERARQUIA LIMPA ===
pub Expressao: ast::Expressao = {
    ExpressaoLogica
};

ExpressaoLogica: ast::Expressao = {
   // Expressões booleanas binárias
    <esq:ExpressaoLogica> "&&" <dir:ExpressaoComparacao> => {
        ast::Expressao::Logica(ast::OperadorLogico::E, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoLogica> "||" <dir:ExpressaoComparacao> => {
        ast::Expressao::Logica(ast::OperadorLogico::Ou, Box::new(esq), Box::new(dir))
    },
    ExpressaoComparacao,
};

ExpressaoComparacao: ast::Expressao = {
    <esq:ExpressaoAritmetica> "==" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::Igual, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> "!=" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::Diferente, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> "<" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::Menor, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> ">" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::MaiorQue, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> ">=" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::MaiorIgual, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> "<=" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::MenorIgual, Box::new(esq), Box::new(dir))
    },
    ExpressaoAritmetica,
};

ExpressaoAritmetica: ast::Expressao = {
    <esq:ExpressaoAritmetica> "+" <dir:ExpressaoTermo> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Soma, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> "-" <dir:ExpressaoTermo> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Subtracao, Box::new(esq), Box::new(dir))
    },
    ExpressaoTermo,
};

ExpressaoTermo: ast::Expressao = {
    <esq:ExpressaoTermo> "*" <dir:ExpressaoUnaria> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Multiplicacao, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoTermo> "/" <dir:ExpressaoUnaria> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Divisao, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoTermo> "%" <dir:ExpressaoUnaria> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Modulo, Box::new(esq), Box::new(dir))
    },
    ExpressaoUnaria,
};

ExpressaoUnaria: ast::Expressao = {
    "!" <expr:ExpressaoUnaria> => {
        ast::Expressao::Unario(ast::OperadorUnario::NegacaoLogica, Box::new(expr))
    },
    "-" <expr:ExpressaoUnaria> => {
        ast::Expressao::Unario(ast::OperadorUnario::NegacaoNumerica, Box::new(expr))
    },
    ExpressaoPostfixa,
};

ExpressaoPostfixa: ast::Expressao = {
    <base:ExpressaoAtomo> => base,
    // Indexação de arrays e coleções: obj[expr]
    <obj:ExpressaoPostfixa> "[" <idx:Expressao> "]" => {
        ast::Expressao::AcessoIndice(Box::new(obj), Box::new(idx))
    },
    <obj:ExpressaoPostfixa> "." <membro:TIdentificador> "(" <args:InnerArgList> => {
        ast::Expressao::ChamadaMetodo(Box::new(obj), membro, args)
    },
    <obj:ExpressaoPostfixa> "." <membro:TIdentificador> => { // Property/field access
        ast::Expressao::AcessoMembro(Box::new(obj), membro)
    },
};

ExpressaoAtomo: ast::Expressao = {
    //<valor:TInteiro> => ast::Expressao::Inteiro(valor),
    //<valor:TString> => ast::Expressao::Texto(valor),
    <lit:ExpressaoLiteral> => lit,
    //<s:TStringInterpolada> => crate::interpolacao::parse_string_interpolada(&s).unwrap(),
    "verdadeiro" => ast::Expressao::Booleano(true),
    "falso" => ast::Expressao::Booleano(false),
    <nome:TIdentificador> "(" <args:InnerArgList> => { // Function call
        ast::Expressao::Chamada(nome, args)
    },
    <obj:CriacaoObjeto> => obj,
    "(" <expr:Expressao> ")" => expr,
    "[" <elementos:ListaElementosArray?> "]" => { // Array literal
        ast::Expressao::ListaLiteral(elementos.unwrap_or_else(Vec::new))
    },
    "este" => ast::Expressao::Este,    // Moved este after specific TIdentificador rules
    <nome:TIdentificador> => ast::Expressao::Identificador(nome), // Variable access (last among identifier-like atoms)
};
// Criação de objeto específica
CriacaoObjeto: ast::Expressao = {
    "novo" <classe:TIdentificador> "(" <args:InnerArgList> => {
        ast::Expressao::NovoObjeto(classe, args)
    },
};

// === VALORES LITERAIS ===
ValorLiteral: ast::Expressao = {
};

ExpressaoLiteral: ast::Expressao = {
    <s:TStringInterpolada> => crate::interpolacao::parse_string_interpolada(&s).unwrap(),
    <t:TString>            => ast::Expressao::Texto(t),
    <n:TInteiro>           => ast::Expressao::Inteiro(n),
    <f:TFlutuanteLiteral>  => ast::Expressao::FlutuanteLiteral(f),
    <df:TDuploLiteral>     => ast::Expressao::DuploLiteral(df),
    <d:TDecimal>           => ast::Expressao::Decimal(d),
};

// === ARGUMENTOS ===
/* ========= LISTAS INTERNAS (entre parênteses) ============= */

#[inline]                     // chamada de função
InnerArgList: Vec<ast::Expressao> = {
    ")"                         => vec![],                 // 0 argumentos
    <lista:ListaArgumentos> ")" => lista,                  // 1+ argumentos
};

#[inline]                     // cabeçalho de função
InnerParamList: Vec<ast::Parametro> = {
    ")"                         => vec![],                 // 0 parâmetros
    <lista:ListaParametros> ")" => lista,                  // 1+ parâmetros
};

// -------------------------------------------------------------------------
// LISTAS SEPARADAS POR VÍRGULA (1 ou mais) – argumentos e parâmetros
// -------------------------------------------------------------------------


// === MAPEAMENTO DE TOKENS ===
extern {
    type Location = usize;
    type Error = ();

    enum Token {
        "usando" => Token::TUsando,
        // Palavras-chave
        "se" => Token::TSe,
        "senão" => Token::TSenao,
        "enquanto" => Token::TEnquanto,
        "para" => Token::TPara,
        "função" => Token::TFuncao,
        "retorne" => Token::TRetorne,
        "imprima" => Token::TImprima,
        "var" => Token::TVar,
        "espaco" => Token::TEspaco,
        "base" => Token::TBase,

        // Tipos
        "inteiro" => Token::TTipoInteiro,
        "texto" => Token::TTipoTexto,
        "booleano" => Token::TTipoBooleano,
    "flutuante" => Token::TTipoFlutuante,
    "duplo" => Token::TTipoDuplo,
        "decimal" => Token::TTipoDecimal,
        "vazio" => Token::TTipoVazio,
        "verdadeiro" => Token::TVerdadeiro,
        "falso" => Token::TFalso,
        "classe" => Token::TClasse,
    "interface" => Token::TInterface,
    "enumeração" => Token::TEnumeracao,
    "construtor" => Token::TConstrutor,
        "publico" => Token::TPublico,
        "privado" => Token::TPrivado,
        "protegido" => Token::TProtegido,
    "redefinível" => Token::TRedefinivel,
    "sobrescreve" => Token::TSobrescreve,
    "abstrata" => Token::TAbstrato,
        "estática" => Token::TEstatica,
        "novo" => Token::TNovo,
        "este" => Token::TEste,
        "obter" => Token::TObter,
        "definir" => Token::TDefinir,
        
        // Operadores
        "=" => Token::TAtribuicao,
        "==" => Token::TIgual,
        "!=" => Token::TDiferente,
        ">" => Token::TMaiorQue,
        ">=" => Token::TMaiorIgual,
        "<" => Token::TMenor,
        "<=" => Token::TMenorIgual,
        "+" => Token::TMais,
        "-" => Token::TMenos,
        "*" => Token::TMultiplicacao,
        "/" => Token::TDivisao,
        "%" => Token::TModulo,
        "&&" => Token::TE,
        "||" => Token::TOu,
        "!" => Token::TNao,
        
        // Delimitadores
        "(" => Token::TParenEsq,
        ")" => Token::TParenDir,
        "{" => Token::TChaveEsq,
        "}" => Token::TChaveDir,
        "[" => Token::TColcheteEsq,
        "]" => Token::TColcheteDir,
        ";" => Token::TPontoVirgula,
        "," => Token::TVirgula,
        "=>" => Token::TSeta,
        "." => Token::TPonto,
        ":" => Token::TDoisPontos,
        
        // Literais
        TString => Token::TString(<String>),
        TIdentificador => Token::TIdentificador(<String>),
        TInteiro => Token::TInteiro(<i64>),
        TDecimal => Token::TDecimal(<String>),
    TFlutuanteLiteral => Token::TFlutuanteLiteral(<String>),
    TDuploLiteral => Token::TDuploLiteral(<String>),
        // === CAMINHOS ===

        TStringInterpolada => Token::TStringInterpolada(<String>),

    }
}