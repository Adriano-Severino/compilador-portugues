use std::str::FromStr;
use crate::ast;
use crate::lexer::Token;

grammar<'input>();

pub Arquivo: ast::Programa = {
    <items:ItemPrograma*> => {
        let mut namespaces = Vec::new();
        let mut declaracoes = Vec::new();
        
        for item in items {
            match item {
                ast::ItemPrograma::Namespace(ns) => namespaces.push(ns),
                ast::ItemPrograma::Declaracao(decl) => declaracoes.push(decl),
            }
        }
        
        ast::Programa { namespaces, declaracoes }
    }
};

ItemPrograma: ast::ItemPrograma = {
    <ns:Namespace> => ast::ItemPrograma::Namespace(ns),
    <decl:Declaracao> => ast::ItemPrograma::Declaracao(decl),
};

// === NAMESPACES ===
Namespace: ast::DeclaracaoNamespace = {
    "espaco" <nome:Identificador> "{" <declaracoes:Declaracao*> "}" => {
        ast::DeclaracaoNamespace { nome, declaracoes }
    }
};

// === DECLARAÇÕES ===
Declaracao: ast::Declaracao = {
    <classe:DeclaracaoClasse> => ast::Declaracao::DeclaracaoClasse(classe),
    <funcao:DeclaracaoFuncao> => ast::Declaracao::DeclaracaoFuncao(funcao),
    <cmd:Comando> => ast::Declaracao::Comando(cmd),
};

// === CLASSES ===
DeclaracaoClasse: ast::DeclaracaoClasse = {
    <modificador:ModificadorAcesso?> "classe" <nome:Identificador> <heranca:("herda" <Identificador>)?> "{" <membros:MembroClasse*> "}" => {
        let mut campos = Vec::new();
        let mut propriedades = Vec::new();
        let mut metodos = Vec::new();
        let mut construtores = Vec::new();

        for membro in membros {
            match membro {
                ast::MembroClasse::Campo(campo) => campos.push(campo),
                ast::MembroClasse::Propriedade(prop) => propriedades.push(prop),
                ast::MembroClasse::Metodo(metodo) => metodos.push(metodo),
                ast::MembroClasse::Construtor(construtor) => construtores.push(construtor),
            }
        }

        ast::DeclaracaoClasse {
            nome,
            classe_pai: heranca,
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            campos,
            propriedades,
            metodos,
            construtores,
            eh_abstrata: false,
        }
    }
};

MembroClasse: ast::MembroClasse = {
    <prop:PropriedadeClasse> => ast::MembroClasse::Propriedade(prop),
    <metodo:MetodoClasse> => ast::MembroClasse::Metodo(metodo),
    <construtor:ConstrutorClasse> => ast::MembroClasse::Construtor(construtor),
    <campo:CampoClasse> => ast::MembroClasse::Campo(campo),
};

// === PROPRIEDADES ===
PropriedadeClasse: ast::PropriedadeClasse = {
    <modificador:ModificadorAcesso?> <tipo:TipoBasico> <nome:Identificador> "{" <acessores:AcessorPropriedade+> "}" => {
        let mut buscar = None;
        let mut definir = None;

        for acessor in acessores {
            match acessor {
                (true, modificador_acessor) => buscar = Some(ast::AcessorPropriedade { 
                    modificador: modificador_acessor, 
                    corpo: None 
                }),
                (false, modificador_acessor) => definir = Some(ast::AcessorPropriedade { 
                    modificador: modificador_acessor, 
                    corpo: None 
                }),
            }
        }

        ast::PropriedadeClasse {
            nome,
            tipo,
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            buscar,
            definir,
            valor_inicial: None,
        }
    }
};

AcessorPropriedade: (bool, Option<ast::ModificadorAcesso>) = {
    <modificador:ModificadorAcesso?> "buscar" ";" => (true, modificador),
    <modificador:ModificadorAcesso?> "definir" ";" => (false, modificador),
};

// === MÉTODOS ===
MetodoClasse: ast::MetodoClasse = {
    // ✅ Método com tipo de retorno e parâmetros opcionais
    <modificador:ModificadorAcesso?> <tipo_retorno:TipoBasico> <nome:Identificador> "(" <params:ParametrosOpcionais> ")" <corpo:BlocoComando> => ast::MetodoClasse {
        nome,
        parametros: params,
        tipo_retorno: Some(tipo_retorno),
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: corpo,
        eh_virtual: false,
        eh_override: false,
        eh_abstrato: false,
        eh_estatico: false,
    },

    // ✅ Método void (sem tipo de retorno)
    <modificador:ModificadorAcesso?> "vazio" <nome:Identificador> "(" <params:ParametrosOpcionais> ")" <corpo:BlocoComando> => ast::MetodoClasse {
        nome,
        parametros: params,
        tipo_retorno: Some(ast::Tipo::Vazio),
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: corpo,
        eh_virtual: false,
        eh_override: false,
        eh_abstrato: false,
        eh_estatico: false,
    },
};

// === CONSTRUTORES ===
ConstrutorClasse: ast::ConstrutorClasse = {
    <modificador:ModificadorAcesso?> <nome:Identificador> "(" <params:ParametrosOpcionais> ")" <corpo:BlocoComando> => {
        ast::ConstrutorClasse {
            parametros: params,
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            corpo: corpo,
        }
    }
};

// === CAMPOS ===
CampoClasse: ast::CampoClasse = {
    <modificador:ModificadorAcesso?> <tipo:TipoBasico> <nome:Identificador> ";" => {
        ast::CampoClasse {
            nome,
            tipo,
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            valor_inicial: None,
            eh_estatico: false,
        }
    }
};

// === FUNÇÕES ===
DeclaracaoFuncao: ast::DeclaracaoFuncao = {
    // Sintaxe 1: Sem tipo de retorno (implícito vazio)
    <modificador:ModificadorAcesso?> "funcao" <nome:Identificador> "(" <params:ParametrosOpcionais> ")" <corpo:BlocoComando> => {
        ast::DeclaracaoFuncao {
            nome,
            parametros: params,
            tipo_retorno: Some(ast::Tipo::Vazio),
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            corpo,
        }
    },

    // Sintaxe 2: Com tipo de retorno usando seta
    <modificador:ModificadorAcesso?> "funcao" <nome:Identificador> "(" <params:ParametrosOpcionais> ")" "=>" <tipo:TipoBasico> <corpo:BlocoComando> => {
        ast::DeclaracaoFuncao {
            nome,
            parametros: params,
            tipo_retorno: Some(tipo),
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            corpo,
        }
    },

    // Sintaxe 3: Tipo no início
    <modificador:ModificadorAcesso?> "funcao" <tipo:TipoBasico> <nome:Identificador> "(" <params:ParametrosOpcionais> ")" <corpo:BlocoComando> => {
        ast::DeclaracaoFuncao {
            nome,
            parametros: params,
            tipo_retorno: Some(tipo),
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            corpo,
        }
    },
};

// === PARÂMETROS ===
ParametrosOpcionais: Vec<ast::Parametro> = {
    <params:(<Parametro> ",")*> <last:Parametro?> => {
        let mut result = params;
        if let Some(param) = last {
            result.push(param);
        }
        result
    }
};

Parametro: ast::Parametro = {
    // ✅ Parâmetro com valor padrão
    <tipo:TipoBasico> <nome:Identificador> "=" <valor:ExpressaoAtomo> => {
        ast::Parametro {
            nome,
            tipo,
            valor_padrao: Some(valor),
        }
    },

    // ✅ Parâmetro sem valor padrão
    <tipo:TipoBasico> <nome:Identificador> => {
        ast::Parametro {
            nome,
            tipo,
            valor_padrao: None,
        }
    },
};

// === COMANDOS ===
Comando: ast::Comando = {
    // ✅ NOVA REGRA: Atribuição a membro (este.propriedade = valor)
    <obj:ExpressaoAtomo> "." <prop:Identificador> "=" <expr:Expressao> ";" => {
        match obj {
            ast::Expressao::Identificador(nome) => {
                ast::Comando::AtribuirPropriedade(nome, prop, expr)
            }
            _ => ast::Comando::AtribuirCampo(Box::new(obj), prop, expr)
        }
    },

    // ✅ Declaração de variável com tipo
    <tipo:TipoBasico> <nome:Identificador> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVariavel(tipo, nome, Some(expr))
    },

    // ✅ Declaração de variável sem inicialização
    <tipo:TipoBasico> <nome:Identificador> ";" => {
        ast::Comando::DeclaracaoVariavel(tipo, nome, None)
    },

    // ✅ Declaração com var (tipo inferido)
    "var" <nome:Identificador> "=" <expr:Expressao> ";" => {
        ast::Comando::DeclaracaoVar(nome, expr)
    },

    // ✅ Atribuição normal
    <nome:Identificador> "=" <expr:Expressao> ";" => {
        ast::Comando::Atribuicao(nome, expr)
    },

    // ✅ Comando de impressão
    "imprima" "(" <expr:Expressao> ")" ";" => {
        ast::Comando::Imprima(expr)
    },

    // ✅ Comando SE
    "se" "(" <cond:Expressao> ")" <then_block:Comando> <else_block:("senão" <Comando>)?> => {
        ast::Comando::Se(cond, Box::new(then_block), else_block.map(Box::new))
    },

    // ✅ Loop ENQUANTO
    "enquanto" "(" <cond:Expressao> ")" <body:Comando> => {
        ast::Comando::Enquanto(cond, Box::new(body))
    },

    // ✅ Loop PARA
    "para" "(" <init:Comando?> <cond:Expressao?> ";" <inc:Comando?> ")" <body:Comando> => {
        ast::Comando::Para(
            init.map(Box::new),
            cond,
            inc.map(Box::new),
            Box::new(body)
        )
    },

    // ✅ Bloco de comandos
    <bloco:BlocoComando> => ast::Comando::Bloco(bloco),

    // ✅ Comando de retorno
    "retorne" <expr:Expressao?> ";" => {
        ast::Comando::Retorne(expr)
    },

    // ✅ Expressão como comando
    <expr:Expressao> ";" => {
        ast::Comando::Expressao(expr)
    },

    // ✅ Criação de objeto
    <tipo:Identificador> <nome:Identificador> "=" "novo" <classe:Identificador> "(" <args:ArgumentosOpcionais> ")" ";" => {
        ast::Comando::CriarObjeto(nome, classe, args)
    },

    // ✅ Chamada de método
    <obj:Identificador> "." <metodo:Identificador> "(" <args:ArgumentosOpcionais> ")" ";" => {
        ast::Comando::ChamarMetodo(obj, metodo, args)
    },
};

BlocoComando: Vec<ast::Comando> = {
    "{" <comandos:Comando*> "}" => comandos
};

// === EXPRESSÕES ===
pub Expressao: ast::Expressao = {
    ExpressaoLogica
};

ExpressaoLogica: ast::Expressao = {
    <esq:ExpressaoLogica> "&&" <dir:ExpressaoComparacao> => {
        ast::Expressao::Logica(ast::OperadorLogico::E, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoLogica> "||" <dir:ExpressaoComparacao> => {
        ast::Expressao::Logica(ast::OperadorLogico::Ou, Box::new(esq), Box::new(dir))
    },
    ExpressaoComparacao
};

ExpressaoComparacao: ast::Expressao = {
    <esq:ExpressaoComparacao> "==" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::Igual, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoComparacao> "!=" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::Diferente, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoComparacao> "<" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::Menor, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoComparacao> ">" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::MaiorQue, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoComparacao> ">=" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::MaiorIgual, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoComparacao> "<=" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::MenorIgual, Box::new(esq), Box::new(dir))
    },
    ExpressaoAritmetica
};

ExpressaoAritmetica: ast::Expressao = {
    <esq:ExpressaoAritmetica> "+" <dir:ExpressaoTermo> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Soma, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> "-" <dir:ExpressaoTermo> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Subtracao, Box::new(esq), Box::new(dir))
    },
    ExpressaoTermo
};

ExpressaoTermo: ast::Expressao = {
    <esq:ExpressaoTermo> "*" <dir:ExpressaoUnaria> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Multiplicacao, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoTermo> "/" <dir:ExpressaoUnaria> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Divisao, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoTermo> "%" <dir:ExpressaoUnaria> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Modulo, Box::new(esq), Box::new(dir))
    },
    ExpressaoUnaria
};

// ✅ NOVA: Expressões unárias
ExpressaoUnaria: ast::Expressao = {
    "!" <expr:ExpressaoUnaria> => {
        ast::Expressao::Unario(ast::OperadorUnario::NegacaoLogica, Box::new(expr))
    },
    "-" <expr:ExpressaoUnaria> => {
        ast::Expressao::Unario(ast::OperadorUnario::NegacaoNumerica, Box::new(expr))
    },
    ExpressaoMembro
};

ExpressaoMembro: ast::Expressao = {
    <obj:ExpressaoMembro> "." <membro:Identificador> "(" <args:ArgumentosOpcionais> ")" => {
        ast::Expressao::ChamadaMetodo(Box::new(obj), membro, args)
    },
    <obj:ExpressaoMembro> "." <membro:Identificador> => {
        ast::Expressao::AcessoMembro(Box::new(obj), membro)
    },
    ExpressaoAtomo
};

ExpressaoAtomo: ast::Expressao = {
    <valor:TInteiro> => ast::Expressao::Inteiro(valor),
    <valor:TString> => ast::Expressao::Texto(valor),
    <valor:StringInterpolada> => valor,
    "verdadeiro" => ast::Expressao::Booleano(true),
    "falso" => ast::Expressao::Booleano(false),
    "este" => ast::Expressao::Este,
    <nome:Identificador> => ast::Expressao::Identificador(nome),
    <nome:Identificador> "(" <args:ArgumentosOpcionais> ")" => {
        ast::Expressao::Chamada(nome, args)
    },
    "novo" <classe:Identificador> "(" <args:ArgumentosOpcionais> ")" => {
        ast::Expressao::NovoObjeto(classe, args)
    },
    "(" <expr:Expressao> ")" => expr,
};

// ✅ NOVA: String interpolada
StringInterpolada: ast::Expressao = {
    TStringInterpolada => {
        match crate::interpolacao::parse_string_interpolada(&<>) {
            Ok(expr) => expr,
            Err(_) => ast::Expressao::Texto("".to_string()),
        }
    }
};

ArgumentosOpcionais: Vec<ast::Expressao> = {
    <args:(<Expressao> ",")*> <last:Expressao?> => {
        let mut result = args;
        if let Some(expr) = last {
            result.push(expr);
        }
        result
    }
};

// === TIPOS ===
TipoBasico: ast::Tipo = {
    "inteiro" => ast::Tipo::Inteiro,
    "texto" => ast::Tipo::Texto,
    "booleano" => ast::Tipo::Booleano,
    "vazio" => ast::Tipo::Vazio,
    <nome:Identificador> => ast::Tipo::Classe(nome),
};

// === MODIFICADORES ===
ModificadorAcesso: ast::ModificadorAcesso = {
    "publico" => ast::ModificadorAcesso::Publico,
    "privado" => ast::ModificadorAcesso::Privado,
    "protegido" => ast::ModificadorAcesso::Protegido,
};

// === TERMINAIS ===
Identificador: String = {
    Token![TIdentificador] => <>
};

// === MAPEAMENTO DE TOKENS ===
extern {
    type Location = usize;
    type Error = ();

    enum Token {
        // Palavras-chave
        "se" => Token::TSe,
        "então" => Token::TEntao,
        "senão" => Token::TSenao,
        "enquanto" => Token::TEnquanto,
        "para" => Token::TPara,
        "funcao" => Token::TFuncao,
        "retorne" => Token::TRetorne,
        "imprima" => Token::TImprima,
        "var" => Token::TVar,
        "espaco" => Token::TEspaco,
        
        // Tipos
        "inteiro" => Token::TTipoInteiro,
        "texto" => Token::TTipoTexto,
        "booleano" => Token::TTipoBooleano,
        "vazio" => Token::TTipoVazio,
        "verdadeiro" => Token::TVerdadeiro,
        "falso" => Token::TFalso,
        
        // OOP
        "classe" => Token::TClasse,
        "herda" => Token::THerda,
        "publico" => Token::TPublico,
        "privado" => Token::TPrivado,
        "protegido" => Token::TProtegido,
        "novo" => Token::TNovo,
        "este" => Token::TEste,
        "buscar" => Token::TBuscar,
        "definir" => Token::TDefinir,
        
        // Operadores
        "=" => Token::TAtribuicao,
        "==" => Token::TIgual,
        "!=" => Token::TDiferente,
        ">" => Token::TMaiorQue,
        ">=" => Token::TMaiorIgual,
        "<" => Token::TMenor,
        "<=" => Token::TMenorIgual,
        "+" => Token::TMais,
        "-" => Token::TMenos,
        "*" => Token::TMultiplicacao,
        "/" => Token::TDivisao,
        "%" => Token::TModulo,
        "&&" => Token::TE,
        "||" => Token::TOu,
        "!" => Token::TNao,
        
        // Delimitadores
        "(" => Token::TParenEsq,
        ")" => Token::TParenDir,
        "{" => Token::TChaveEsq,
        "}" => Token::TChaveDir,
        ";" => Token::TPontoVirgula,
        "," => Token::TVirgula,
        "=>" => Token::TSeta,
        "." => Token::TPonto,
        
        // Literais
        TString(<String>) => Token::TString(<>),
        TIdentificador(<String>) => Token::TIdentificador(<>),
        TInteiro(<i64>) => Token::TInteiro(<>),
        TStringInterpolada(<String>) => Token::TStringInterpolada(<>),
    }
}