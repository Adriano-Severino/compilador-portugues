use super::lexer::Token;
use crate::ast::*;

grammar;

// --- REGRAS DE TOPO ---
// Regra pública para o arquivo inteiro. Resolve a ambiguidade.
pub Arquivo: Programa = <p:Programa> => p;

// Regra interna para o conteúdo do programa
Programa: Programa = {
    <items:Item*> => {
        let mut namespaces = Vec::new();
        let mut declaracoes = Vec::new();
        for item in items {
            match item {
                ItemPrograma::Namespace(n) => namespaces.push(n),
                ItemPrograma::Declaracao(d) => declaracoes.push(d),
            }
        }
        Programa { namespaces, declaracoes }
    }
};

// Um "Item" pode ser um namespace ou uma declaração global
ItemPrograma: ItemPrograma = {
    <n:Namespace> => ItemPrograma::Namespace(n),
    <d:Declaracao> => ItemPrograma::Declaracao(d),
};


// --- NAMESPACE ---
Namespace: DeclaracaoNamespace = {
    "espaco" <nome:NomeQualificado> "{" <declaracoes:Declaracao*> "}" => {
        DeclaracaoNamespace {
            nome: nome,
            declaracoes: declaracoes,
        }
    },
};

// --- DECLARAÇÕES GLOBAIS ---
Declaracao: Declaracao = {
    <c:DeclaracaoClasse> => Declaracao::DeclaracaoClasse(c),
    
    // REGRAS DE 'funcao' REINTEGRADAS
    <f:FuncaoSemParams> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComUmParam> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComDoisParams> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComTresParams> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComQuatroParams> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComCincoParams> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComSeta> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComSetaUmParam> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComSetaDoisParams> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComSetaTresParams> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComSetaQuatroParams> => Declaracao::DeclaracaoFuncao(f),
    <f:FuncaoComSetaCincoParams> => Declaracao::DeclaracaoFuncao(f),
    
    <m:DeclaracaoMetodo> => Declaracao::DeclaracaoMetodo(m),
    <cmd:Comando> => Declaracao::Comando(cmd),
};

// --- CLASSES E SEUS MEMBROS ---
DeclaracaoClasse: DeclaracaoClasse = {
    <modificador:ModificadorAcesso?> "classe" <nome:Identificador> "{" <membros:MembroClasse*> "}" => {
        let mut campos = Vec::new();
        let mut propriedades = Vec::new();
        let mut metodos = Vec::new();
        let mut construtores = Vec::new();

        for membro in membros {
            match membro {
                MembroClasse::Campo(c) => campos.push(c),
                MembroClasse::Propriedade(p) => propriedades.push(p),
                MembroClasse::Metodo(m) => metodos.push(m),
                MembroClasse::Construtor(c) => construtores.push(c),
            }
        }
        
        DeclaracaoClasse {
            nome,
            modificador: modificador.unwrap_or(ModificadorAcesso::Privado),
            classe_pai: None,
            campos,
            propriedades,
            metodos,
            construtores,
            eh_abstrata: false,
        }
    }
};

MembroClasse: MembroClasse = {
    <p:PropriedadeClasse> => MembroClasse::Propriedade(p),
    <m:MetodoClasse> => MembroClasse::Metodo(m),
    <c:Construtor> => MembroClasse::Construtor(c),
};

PropriedadeClasse: PropriedadeClasse = {
    <modificador:ModificadorAcesso> <tipo:Tipo> <nome:Identificador> "{" <acessores:Acessor*> "}" => {
        let mut buscar = None;
        let mut definir = None;
        for acc in acessores {
            match acc {
                (Token::TBuscar, m) => buscar = Some(AcessorPropriedade { modificador: m, corpo: None }),
                (Token::TDefinir, m) => definir = Some(AcessorPropriedade { modificador: m, corpo: None }),
            }
        }
        PropriedadeClasse { nome, tipo, modificador, buscar, definir, valor_inicial: None }
    }
};

Acessor: (Token, Option<ModificadorAcesso>) = {
    "buscar" ";" => (Token::TBuscar, None),
    "definir" ";" => (Token::TDefinir, None),
    <modificador:ModificadorAcesso> "buscar" ";" => (Token::TBuscar, Some(modificador)),
    <modificador:ModificadorAcesso> "definir" ";" => (Token::TDefinir, Some(modificador)),
};

MetodoClasse: MetodoClasse = {
    <modificador:ModificadorAcesso> <tipo:Tipo> <nome:Identificador> "(" <params:ListaParametros> ")" <corpo:Bloco> => MetodoClasse {
        nome,
        parametros: params,
        tipo_retorno: Some(tipo),
        modificador,
        corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] },
        eh_virtual: false, eh_override: false, eh_abstrato: false, eh_estatico: false,
    },
};

Construtor: Construtor = {
    <modificador:ModificadorAcesso> <nome:Identificador> "(" <params:ListaParametros> ")" <corpo:Bloco> => {
        // Validação: nome do construtor deve ser o mesmo da classe (a ser feita no analisador semântico)
        Construtor {
            parametros: params,
            modificador,
            corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] },
        }
    }
};

// --- MÉTODOS INDEPENDENTES (ESTILO C#) ---
DeclaracaoMetodo: DeclaracaoMetodo = {
    <modificador:ModificadorAcesso> <tipo:Tipo> <nome:Identificador> "(" <params:ListaParametros> ")" <corpo:Bloco> => DeclaracaoMetodo {
        nome,
        parametros: params,
        tipo_retorno: Some(tipo),
        modificador,
        corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] },
        eh_estatico: false,
    },
};

// --- FUNÇÕES (SINTAXE ANTIGA) ---
// Regras de FuncaoSemParams, FuncaoComUmParam, etc. do seu código antigo [1]
FuncaoSemParams: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: Vec::new(), tipo_retorno: None, modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, "funcao" <retorno:Tipo> <nome:Identificador> "(" ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: Vec::new(), tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComUmParam: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param], tipo_retorno: None, modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, "funcao" <retorno:Tipo> <nome:Identificador> "(" <param:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComDoisParams: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2], tipo_retorno: None, modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, "funcao" <retorno:Tipo> <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComTresParams: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2, param3], tipo_retorno: None, modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, "funcao" <retorno:Tipo> <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2, param3], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComQuatroParams: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> "," <param4:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2, param3, param4], tipo_retorno: None, modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, "funcao" <retorno:Tipo> <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> "," <param4:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2, param3, param4], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComCincoParams: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> "," <param4:Parametro> "," <param5:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2, param3, param4, param5], tipo_retorno: None, modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, "funcao" <retorno:Tipo> <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> "," <param4:Parametro> "," <param5:Parametro> ")" <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2, param3, param4, param5], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComSeta: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" ")" "=>" <retorno:Tipo> <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: Vec::new(), tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComSetaUmParam: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param:Parametro> ")" "=>" <retorno:Tipo> <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComSetaDoisParams: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> ")" "=>" <retorno:Tipo> <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComSetaTresParams: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> ")" "=>" <retorno:Tipo> <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2, param3], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComSetaQuatroParams: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> "," <param4:Parametro> ")" "=>" <retorno:Tipo> <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2, param3, param4], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };
FuncaoComSetaCincoParams: DeclaracaoFuncao = { "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> "," <param4:Parametro> "," <param5:Parametro> ")" "=>" <retorno:Tipo> <corpo:Bloco> => { DeclaracaoFuncao { nome, parametros: vec![param1, param2, param3, param4, param5], tipo_retorno: Some(retorno), modificador: ModificadorAcesso::Publico, corpo: match corpo { Comando::Bloco(c) => c, cmd => vec![cmd] } } }, };

// --- COMANDOS ---
Comando: Comando = {
    <cmd:ComandoSimples> ";" => cmd,
    <bloco:Bloco> => bloco,
    <se:ComandoSe> => se,
    <enquanto:ComandoEnquanto> => enquanto,
};

ComandoSimples: Comando = {
    "imprima" "(" <expr:Expressao> ")" => Comando::Imprima(expr),
    "var" <nome:Identificador> "=" <valor:Expressao> => Comando::DeclaracaoVar(nome, valor),
    <tipo:Tipo> <nome:Identificador> "=" <valor:Expressao> => Comando::DeclaracaoVariavel(tipo, nome, Some(valor)),
    <nome:Identificador> "=" <valor:Expressao> => Comando::Atribuicao(nome, valor),
    "retorne" <expr:Expressao> => Comando::Retorne(Some(expr)),
    "retorne" => Comando::Retorne(None),
    <expr:Expressao> => Comando::Expressao(expr),
};

Bloco: Comando = {
    "{" <comandos:Comando*> "}" => Comando::Bloco(comandos),
};

ComandoSe: Comando = {
    "se" "(" <cond:Expressao> ")" <bloco_then:Bloco> "senão" <bloco_else:Bloco> => Comando::Se(cond, Box::new(bloco_then), Some(Box::new(bloco_else))),
    "se" "(" <cond:Expressao> ")" <bloco:Bloco> => Comando::Se(cond, Box::new(bloco), None),
};

ComandoEnquanto: Comando = {
    "enquanto" "(" <cond:Expressao> ")" <bloco:Bloco> => Comando::Enquanto(cond, Box::new(bloco)),
};

// --- EXPRESSÕES ---
pub Expressao: Expressao = {
    <val:TStringInterpolada> => Expressao::Texto(val), 
    <id:Identificador> => Expressao::Identificador(id),
    <n:NumeroLiteral> => Expressao::Inteiro(n),
    <s:StringLiteral> => Expressao::Texto(s),
    <b:BooleanoLiteral> => Expressao::Booleano(b),
    "novo" <classe:Identificador> "(" <args:ListaArgumentos> ")" => Expressao::NovoObjeto(classe, args),
};

BooleanoLiteral: bool = {
    "verdadeiro" => true,
    "falso" => false,
};

// --- HELPERS E LISTAS ---
NomeQualificado: String = {
    <head:Identificador> <tail:("." <Identificador>)*> => {
        let mut result = head;
        for part in tail {
            result.push('.');
            result.push_str(&part.1);
        }
        result
    }
};

ListaParametros: Vec<Parametro> = { <params:(<Parametro> ",")*> <last:Parametro?> => { let mut v = params; if let Some(l) = last { v.push(l); } v } };
ListaArgumentos: Vec<Expressao> = { <args:(<Expressao> ",")*> <last:Expressao?> => { let mut v = args; if let Some(l) = last { v.push(l); } v } };

Parametro: Parametro = { <tipo:Tipo> <nome:Identificador> => Parametro { nome, tipo, valor_padrao: None }, };

Tipo: Tipo = {
    "inteiro" => Tipo::Inteiro, "texto" => Tipo::Texto,
    "booleano" => Tipo::Booleano, "vazio" => Tipo::Vazio,
    <nome:Identificador> => Tipo::Classe(nome),
};

ModificadorAcesso: ModificadorAcesso = {
    "publico" => ModificadorAcesso::Publico,
    "privado" => ModificadorAcesso::Privado,
    "protegido" => ModificadorAcesso::Protegido,
};

Identificador: String = <id:TIdentificador> => id;
NumeroLiteral: i64 = <n:TInteiro> => n;
StringLiteral: String = <s:TString> => s;


// --- TOKENS EXTERNOS ---
extern {
    type Location = usize; type Error = String;
    enum Token {
        "espaco" => Token::TEspaco, "var" => Token::TVar, "buscar" => Token::TBuscar,
        "definir" => Token::TDefinir, "se" => Token::TSe, "então" => Token::TEntao,
        "senão" => Token::TSenao, "enquanto" => Token::TEnquanto, "funcao" => Token::TFuncao,
        "metodo" => Token::TMetodo, "retorne" => Token::TRetorne, "imprima" => Token::TImprima,
        "inteiro" => Token::TTipoInteiro, "texto" => Token::TTipoTexto, "booleano" => Token::TTipoBooleano,
        "vazio" => Token::TTipoVazio, "verdadeiro" => Token::TVerdadeiro, "falso" => Token::TFalso,
        "novo" => Token::TNovo, "classe" => Token::TClasse, "publico" => Token::TPublico,
        "privado" => Token::TPrivado, "protegido" => Token::TProtegido,
        "=" => Token::TAtribuicao, "==" => Token::TIgual, "!=" => Token::TDiferente,
        ">" => Token::TMaiorQue, ">=" => Token::TMaiorIgual, "<" => Token::TMenor,
        "<=" => Token::TMenorIgual, "+" => Token::TMais, "-" => Token::TMenos,
        "*" => Token::TMultiplicacao, "/" => Token::TDivisao, "%" => Token::TModulo,
        "(" => Token::TParenEsq, ")" => Token::TParenDir, "{" => Token::TChaveEsq,
        "}" => Token::TChaveDir, ";" => Token::TPontoVirgula, "," => Token::TVirgula,
        "." => Token::TPonto, "=>" => Token::TSeta,
        TStringInterpolada => Token::TStringInterpolada(<String>),
        TString => Token::TString(<String>),
        TIdentificador => Token::TIdentificador(<String>),
        TInteiro => Token::TInteiro(<i64>),
    }
}

// --- ENUMERADORES INTERNOS ---
enum ItemPrograma { Namespace(DeclaracaoNamespace), Declaracao(Declaracao), }
enum MembroClasse { Campo(CampoClasse), Propriedade(PropriedadeClasse), Metodo(MetodoClasse), Construtor(Construtor), }
