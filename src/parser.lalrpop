use crate::ast;
use crate::lexer::Token;
use crate::interpolacao::parse_string_interpolada;

grammar;

// === PROGRAMA PRINCIPAL ===
pub Arquivo: ast::Programa = <Programa>;

Programa: ast::Programa = {
    <items:ItemPrograma*> => {
        let mut namespaces = Vec::new();
        let mut declaracoes = Vec::new();
        for item in items {
            match item {
                ast::ItemPrograma::Namespace(n) => namespaces.push(n),
                ast::ItemPrograma::Declaracao(d) => declaracoes.push(d),
            }
        }
        ast::Programa { namespaces, declaracoes }
    }
};

ItemPrograma: ast::ItemPrograma = {
    <n:Namespace> => ast::ItemPrograma::Namespace(n),
    <d:Declaracao> => ast::ItemPrograma::Declaracao(d),
};

// === NAMESPACES ===
Namespace: ast::DeclaracaoNamespace = {
    "espaco" <nome:NomeQualificado> "{" <declaracoes:Declaracao*> "}" => ast::DeclaracaoNamespace {
        nome,
        declaracoes,
    }
};

// === DECLARAÇÕES ===
Declaracao: ast::Declaracao = {
    <c:DeclaracaoClasse> => ast::Declaracao::DeclaracaoClasse(c),
    <f:DeclaracaoFuncao> => ast::Declaracao::DeclaracaoFuncao(f),
    <cmd:Comando> => ast::Declaracao::Comando(cmd),
};

// === CLASSES ===
DeclaracaoClasse: ast::DeclaracaoClasse = {
    <modificador:ModificadorAcesso?> "classe" <nome:Identificador> <heranca:("herda" <Identificador>)?> "{" <membros:MembroClasse*> "}" => {
        let mut campos = Vec::new();
        let mut propriedades = Vec::new();
        let mut metodos = Vec::new();
        let mut construtores = Vec::new();
        
        for membro in membros {
            match membro {
                ast::MembroClasse::Campo(c) => campos.push(c),
                ast::MembroClasse::Propriedade(p) => propriedades.push(p),
                ast::MembroClasse::Metodo(m) => metodos.push(m),
                ast::MembroClasse::Construtor(c) => construtores.push(c),
            }
        }
        
        ast::DeclaracaoClasse {
            nome,
            classe_pai: heranca,
            modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
            campos,
            propriedades,
            metodos,
            construtores,
            eh_abstrata: false,
        }
    }
};

MembroClasse: ast::MembroClasse = {
    <p:PropriedadeClasse> => ast::MembroClasse::Propriedade(p),
    <m:MetodoClasse> => ast::MembroClasse::Metodo(m),
    <c:Construtor> => ast::MembroClasse::Construtor(c),
    <f:CampoClasse> => ast::MembroClasse::Campo(f),
};

// === CAMPOS ===
CampoClasse: ast::CampoClasse = {
    <modificador:ModificadorAcesso?> <tipo:Tipo> <nome:Identificador> <valor_inicial:("=" <Expressao>)?> ";" => ast::CampoClasse {
        nome,
        tipo,
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Privado),
        valor_inicial,
        eh_estatico: false,
    },
};

// === PROPRIEDADES ===
PropriedadeClasse: ast::PropriedadeClasse = {
    <modificador:ModificadorAcesso> <tipo:Tipo> <nome:Identificador> "{" <acessores:Acessor*> "}" => {
        let mut buscar = None;
        let mut definir = None;
        
        for (tipo_acessor, mod_acessor) in acessores {
            match tipo_acessor.as_str() {
                "buscar" => buscar = Some(ast::AcessorPropriedade { 
                    modificador: mod_acessor, 
                    corpo: None 
                }),
                "definir" => definir = Some(ast::AcessorPropriedade { 
                    modificador: mod_acessor, 
                    corpo: None 
                }),
                _ => {}
            }
        }
        
        ast::PropriedadeClasse { 
            nome, 
            tipo, 
            modificador, 
            buscar, 
            definir, 
            valor_inicial: None 
        }
    }
};

Acessor: (String, Option<ast::ModificadorAcesso>) = {
    <modificador:ModificadorAcesso?> "buscar" ";" => ("buscar".to_string(), modificador),
    <modificador:ModificadorAcesso?> "definir" ";" => ("definir".to_string(), modificador),
};

// === MÉTODOS ===
MetodoClasse: ast::MetodoClasse = {
    // Método sem parâmetros
    <modificador:ModificadorAcesso?> <tipo_retorno:Tipo> <nome:Identificador> "(" ")" <corpo:Bloco> => ast::MetodoClasse {
        nome,
        parametros: Vec::new(),
        tipo_retorno: Some(tipo_retorno),
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { 
            ast::Comando::Bloco(c) => c, 
            cmd => vec![cmd] 
        },
        eh_virtual: false,
        eh_override: false,
        eh_abstrato: false,
        eh_estatico: false,
    },
    // Método com parâmetros
    <modificador:ModificadorAcesso?> <tipo_retorno:Tipo> <nome:Identificador> "(" <params:ListaParametros> ")" <corpo:Bloco> => ast::MetodoClasse {
        nome,
        parametros: params,
        tipo_retorno: Some(tipo_retorno),
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { 
            ast::Comando::Bloco(c) => c, 
            cmd => vec![cmd] 
        },
        eh_virtual: false,
        eh_override: false,
        eh_abstrato: false,
        eh_estatico: false,
    },
};

// === CONSTRUTORES ===
Construtor: ast::Construtor = {
    // Construtor sem parâmetros
    <modificador:ModificadorAcesso?> <_nome_classe:Identificador> "(" ")" <corpo:Bloco> => ast::Construtor {
        parametros: Vec::new(),
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { 
            ast::Comando::Bloco(c) => c, 
            cmd => vec![cmd] 
        },
    },
    // Construtor com parâmetros
    <modificador:ModificadorAcesso?> <_nome_classe:Identificador> "(" <params:ListaParametros> ")" <corpo:Bloco> => ast::Construtor {
        parametros: params,
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { 
            ast::Comando::Bloco(c) => c, 
            cmd => vec![cmd] 
        },
    },
};

// === FUNÇÕES GLOBAIS ===
DeclaracaoFuncao: ast::DeclaracaoFuncao = {
    // Função sem parâmetros, sem tipo de retorno
    <modificador:ModificadorAcesso?> "funcao" <nome:Identificador> "(" ")" <corpo:Bloco> => ast::DeclaracaoFuncao {
        nome,
        parametros: Vec::new(),
        tipo_retorno: None,
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { ast::Comando::Bloco(c) => c, cmd => vec![cmd] },
    },
    
    // Função com parâmetros, sem tipo de retorno
    <modificador:ModificadorAcesso?> "funcao" <nome:Identificador> "(" <params:ListaParametros> ")" <corpo:Bloco> => ast::DeclaracaoFuncao {
        nome,
        parametros: params,
        tipo_retorno: None,
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { ast::Comando::Bloco(c) => c, cmd => vec![cmd] },
    },
    
    // Função sem parâmetros, com tipo de retorno (seta)
    <modificador:ModificadorAcesso?> "funcao" <nome:Identificador> "(" ")" "=>" <tipo_retorno:Tipo> <corpo:Bloco> => ast::DeclaracaoFuncao {
        nome,
        parametros: Vec::new(),
        tipo_retorno: Some(tipo_retorno),
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { ast::Comando::Bloco(c) => c, cmd => vec![cmd] },
    },
    
    // Função com parâmetros, com tipo de retorno (seta)
    <modificador:ModificadorAcesso?> "funcao" <nome:Identificador> "(" <params:ListaParametros> ")" "=>" <tipo_retorno:Tipo> <corpo:Bloco> => ast::DeclaracaoFuncao {
        nome,
        parametros: params,
        tipo_retorno: Some(tipo_retorno),
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { ast::Comando::Bloco(c) => c, cmd => vec![cmd] },
    },
    
    // Função sem parâmetros, tipo no início
    <modificador:ModificadorAcesso?> "funcao" <tipo_retorno:Tipo> <nome:Identificador> "(" ")" <corpo:Bloco> => ast::DeclaracaoFuncao {
        nome,
        parametros: Vec::new(),
        tipo_retorno: Some(tipo_retorno),
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { ast::Comando::Bloco(c) => c, cmd => vec![cmd] },
    },
    
    // Função com parâmetros, tipo no início
    <modificador:ModificadorAcesso?> "funcao" <tipo_retorno:Tipo> <nome:Identificador> "(" <params:ListaParametros> ")" <corpo:Bloco> => ast::DeclaracaoFuncao {
        nome,
        parametros: params,
        tipo_retorno: Some(tipo_retorno),
        modificador: modificador.unwrap_or(ast::ModificadorAcesso::Publico),
        corpo: match corpo { ast::Comando::Bloco(c) => c, cmd => vec![cmd] },
    },
};

// === LISTAS DE PARÂMETROS ===
ListaParametros: Vec<ast::Parametro> = {
    <param:Parametro> => vec![param],
    <params:ListaParametros> "," <param:Parametro> => {
        let mut params = params;
        params.push(param);
        params
    },
};

Parametro: ast::Parametro = {
    <tipo:Tipo> <nome:Identificador> <valor_padrao:("=" <Expressao>)?> => ast::Parametro { 
        nome, 
        tipo, 
        valor_padrao 
    },
};

// === LISTAS DE ARGUMENTOS ===
ListaArgumentos: Vec<ast::Expressao> = {
    <expr:Expressao> => vec![expr],
    <args:ListaArgumentos> "," <expr:Expressao> => {
        let mut args = args;
        args.push(expr);
        args
    },
};

// === COMANDOS ===
Comando: ast::Comando = {
    <cmd:ComandoSimples> => cmd,
    <bloco:Bloco> => bloco,
    <se:ComandoSe> => se,
    <enquanto:ComandoEnquanto> => enquanto,
};

ComandoSimples: ast::Comando = {
    "imprima" "(" <expr:Expressao> ")" ";" => ast::Comando::Imprima(expr),
    "var" <nome:Identificador> "=" <valor:Expressao> ";" => ast::Comando::DeclaracaoVar(nome, valor),
    <tipo:Tipo> <nome:Identificador> <valor:("=" <Expressao>)?> ";" => ast::Comando::DeclaracaoVariavel(tipo, nome, valor),
    <target:AcessoMembro> "=" <valor:Expressao> ";" => ast::Comando::AtribuirCampo(
        target.0, target.1, valor
    ),
    <nome:Identificador> "=" <valor:Expressao> ";" => ast::Comando::Atribuicao(nome, valor),
    "retorne" <expr:Expressao?> ";" => ast::Comando::Retorne(expr),
    <expr:Expressao> ";" => ast::Comando::Expressao(expr),
};

Bloco: ast::Comando = {
    "{" <comandos:Comando*> "}" => ast::Comando::Bloco(comandos),
};

ComandoSe: ast::Comando = {
    "se" "(" <cond:Expressao> ")" <bloco_then:Bloco> <senao:ClausulaSenao?> => ast::Comando::Se(
        cond,
        Box::new(bloco_then),
        senao.map(Box::new)
    ),
};

ClausulaSenao: ast::Comando = {
    "senão" <cmd_se:ComandoSe> => cmd_se,
    "senão" <bloco:Bloco> => bloco,
};

ComandoEnquanto: ast::Comando = {
    "enquanto" <cond:Expressao> <bloco:Bloco> => ast::Comando::Enquanto(cond, Box::new(bloco)),
};

// === EXPRESSÕES ===
pub Expressao: ast::Expressao = {
    <val:TStringInterpolada> =>? parse_string_interpolada(&val).map_err(|e| lalrpop_util::ParseError::User { error: e }),
    <expr:ExpressaoLogica> => expr,
};

ExpressaoLogica: ast::Expressao = {
    <esq:ExpressaoLogica> "||" <dir:ExpressaoComparacao> => {
        ast::Expressao::Logica(ast::OperadorLogico::Ou, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoLogica> "&&" <dir:ExpressaoComparacao> => {
        ast::Expressao::Logica(ast::OperadorLogico::E, Box::new(esq), Box::new(dir))
    },
    <expr:ExpressaoComparacao> => expr,
};

ExpressaoComparacao: ast::Expressao = {
    <esq:ExpressaoAritmetica> "==" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::Igual, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> "!=" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::Diferente, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> "<" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::Menor, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> ">" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::MaiorQue, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> ">=" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::MaiorIgual, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> "<=" <dir:ExpressaoAritmetica> => {
        ast::Expressao::Comparacao(ast::OperadorComparacao::MenorIgual, Box::new(esq), Box::new(dir))
    },
    <expr:ExpressaoAritmetica> => expr,
};

ExpressaoAritmetica: ast::Expressao = {
    <esq:ExpressaoAritmetica> "+" <dir:Termo> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Soma, Box::new(esq), Box::new(dir))
    },
    <esq:ExpressaoAritmetica> "-" <dir:Termo> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Subtracao, Box::new(esq), Box::new(dir))
    },
    <termo:Termo> => termo,
};

Termo: ast::Expressao = {
    <esq:Termo> "*" <dir:Fator> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Multiplicacao, Box::new(esq), Box::new(dir))
    },
    <esq:Termo> "/" <dir:Fator> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Divisao, Box::new(esq), Box::new(dir))
    },
    <esq:Termo> "%" <dir:Fator> => {
        ast::Expressao::Aritmetica(ast::OperadorAritmetico::Modulo, Box::new(esq), Box::new(dir))
    },
    <fator:Fator> => fator,
};

Fator: ast::Expressao = {
    // Criação de objeto sem argumentos
    "novo" <classe:Identificador> "(" ")" => {
        ast::Expressao::NovoObjeto(classe, Vec::new())
    },
    // Criação de objeto com argumentos
    "novo" <classe:Identificador> "(" <args:ListaArgumentos> ")" => {
        ast::Expressao::NovoObjeto(classe, args)
    },
    <primario:Primario> => primario,
};

Primario: ast::Expressao = {
    <n:TInteiro> => ast::Expressao::Inteiro(n),
    <s:TString> => ast::Expressao::Texto(s),
    "verdadeiro" => ast::Expressao::Booleano(true),
    "falso" => ast::Expressao::Booleano(false),
    "este" => ast::Expressao::Este,
    <acesso:AcessoMembro> => ast::Expressao::AcessoMembro(Box::new(acesso.0), acesso.1),
    <chamada:ChamadaFuncao> => chamada,
    <id:Identificador> => ast::Expressao::Identificador(id),
    "(" <expr:Expressao> ")" => expr,
};

// === ACESSO A MEMBROS ===
AcessoMembro: (ast::Expressao, String) = {
    <obj:AcessoMembro> "." <membro:Identificador> => {
        (ast::Expressao::AcessoMembro(Box::new(obj.0), obj.1), membro)
    },
    <obj:Identificador> "." <membro:Identificador> => {
        (ast::Expressao::Identificador(obj), membro)
    },
    "este" "." <membro:Identificador> => {
        (ast::Expressao::Este, membro)
    },
};

// === CHAMADAS DE FUNÇÃO ===
ChamadaFuncao: ast::Expressao = {
    // Chamada de método sem argumentos
    <obj:AcessoMembro> "(" ")" => {
        ast::Expressao::ChamadaMetodo(Box::new(obj.0), obj.1, Vec::new())
    },
    // Chamada de método com argumentos
    <obj:AcessoMembro> "(" <args:ListaArgumentos> ")" => {
        ast::Expressao::ChamadaMetodo(Box::new(obj.0), obj.1, args)
    },
    // Chamada de função sem argumentos
    <nome:Identificador> "(" ")" => {
        ast::Expressao::Chamada(nome, Vec::new())
    },
    // Chamada de função com argumentos
    <nome:Identificador> "(" <args:ListaArgumentos> ")" => {
        ast::Expressao::Chamada(nome, args)
    },
};

// === HELPERS ===
NomeQualificado: String = {
    <head:Identificador> <tail:("." <Identificador>)*> => {
        let mut result = head;
        for ident_part in tail { // `tail` is Vec<String>, so `ident_part` is String
            result.push('.');
            result.push_str(&ident_part);
        }
        result
    }
};

Tipo: ast::Tipo = {
    "inteiro" => ast::Tipo::Inteiro,
    "texto" => ast::Tipo::Texto,
    "booleano" => ast::Tipo::Booleano,
    "vazio" => ast::Tipo::Vazio,
    <nome:Identificador> => ast::Tipo::Classe(nome),
};

ModificadorAcesso: ast::ModificadorAcesso = {
    "publico" => ast::ModificadorAcesso::Publico,
    "privado" => ast::ModificadorAcesso::Privado,
    "protegido" => ast::ModificadorAcesso::Protegido,
};

Identificador: String = <s:TIdentificador> => s;

// === TOKENS EXTERNOS ===
extern {
    type Location = usize;
    type Error = String;

    enum Token {
        "espaco" => Token::TEspaco,
        "classe" => Token::TClasse,
        "herda" => Token::THerda,
        "funcao" => Token::TFuncao,
        "publico" => Token::TPublico,
        "privado" => Token::TPrivado,
        "protegido" => Token::TProtegido,
        "novo" => Token::TNovo,
        "este" => Token::TEste,
        "buscar" => Token::TBuscar,
        "definir" => Token::TDefinir,
        "se" => Token::TSe,
        "senão" => Token::TSenao,
        "enquanto" => Token::TEnquanto,
        "imprima" => Token::TImprima,
        "retorne" => Token::TRetorne,
        "var" => Token::TVar,
        "inteiro" => Token::TTipoInteiro,
        "texto" => Token::TTipoTexto,
        "booleano" => Token::TTipoBooleano,
        "vazio" => Token::TTipoVazio,
        "verdadeiro" => Token::TVerdadeiro,
        "falso" => Token::TFalso,
        "=" => Token::TAtribuicao,
        "==" => Token::TIgual,
        "!=" => Token::TDiferente,
        "<" => Token::TMenor,
        ">" => Token::TMaiorQue,
        ">=" => Token::TMaiorIgual,
        "<=" => Token::TMenorIgual,
        "+" => Token::TMais,
        "-" => Token::TMenos,
        "*" => Token::TMultiplicacao,
        "/" => Token::TDivisao,
        "%" => Token::TModulo,
        "&&" => Token::TE,
        "||" => Token::TOu,
        "(" => Token::TParenEsq,
        ")" => Token::TParenDir,
        "{" => Token::TChaveEsq,
        "}" => Token::TChaveDir,
        ";" => Token::TPontoVirgula,
        "," => Token::TVirgula,
        "." => Token::TPonto,
        "=>" => Token::TSeta,
        TStringInterpolada => Token::TStringInterpolada(<String>),
        TString => Token::TString(<String>),
        TIdentificador => Token::TIdentificador(<String>),
        TInteiro => Token::TInteiro(<i64>),
    }
}