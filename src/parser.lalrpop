use super::lexer::Token;
use crate::ast::*;

grammar;

pub Programa: Programa = {
    <declaracoes:Declaracao*> => Programa { declaracoes },
};

Declaracao: Declaracao = {
    <cmd:Comando> => Declaracao::Comando(cmd),
    <funcao:FuncaoSemParams> => Declaracao::DeclaracaoFuncao(funcao),
    <funcao:FuncaoComUmParam> => Declaracao::DeclaracaoFuncao(funcao),
    <funcao:FuncaoComDoisParams> => Declaracao::DeclaracaoFuncao(funcao),
    <funcao:FuncaoComTresParams> => Declaracao::DeclaracaoFuncao(funcao),
    <funcao:FuncaoComSeta> => Declaracao::DeclaracaoFuncao(funcao),
    <funcao:FuncaoComSetaUmParam> => Declaracao::DeclaracaoFuncao(funcao),
    <funcao:FuncaoComSetaDoisParams> => Declaracao::DeclaracaoFuncao(funcao),
    <funcao:FuncaoComSetaTresParams> => Declaracao::DeclaracaoFuncao(funcao),
};

Comando: Comando = {
    <cmd:ComandoSimples> ";" => cmd,
    <bloco:Bloco> => bloco,
    <se:ComandoSeSimples> => se,
    <enquanto:ComandoEnquanto> => enquanto,
};

ComandoSimples: Comando = {
    "imprima" "(" <expr:Expressao> ")" => Comando::Imprima(expr),
    <tipo:Tipo> <nome:Identificador> => 
        Comando::DeclaracaoVariavel(tipo, nome, None),
    <tipo:Tipo> <nome:Identificador> "=" <valor:Expressao> => 
        Comando::DeclaracaoVariavel(tipo, nome, Some(valor)),
    <nome:Identificador> "=" <valor:Expressao> => 
        Comando::Atribuicao(nome, valor),
    "retorne" <expr:Expressao> => Comando::Retorne(Some(expr)),
    "retorne" => Comando::Retorne(None),
    <expr:Expressao> => Comando::Expressao(expr),
};

ComandoSeSimples: Comando = {
    "se" <cond:Expressao> "então" <bloco:Bloco> => 
        Comando::Se(cond, Box::new(bloco), None),
};

ComandoEnquanto: Comando = {
    "enquanto" <cond:Expressao> <bloco:Bloco> => 
        Comando::Enquanto(cond, Box::new(bloco)),
};

Bloco: Comando = {
    "{" <comandos:Comando*> "}" => Comando::Bloco(comandos),
};

// Sintaxe 1: Sem parâmetros, sem tipo de retorno
FuncaoSemParams: DeclaracaoFuncao = {
    "funcao" <nome:Identificador> "(" ")" <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: Vec::new(),
            tipo_retorno: None,
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
    // Sintaxe 5: Tipo no início, sem parâmetros
    "funcao" <retorno:Tipo> <nome:Identificador> "(" ")" <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: Vec::new(),
            tipo_retorno: Some(retorno),
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
};

// Sintaxe 2: Com um parâmetro, sem tipo de retorno
FuncaoComUmParam: DeclaracaoFuncao = {
    "funcao" <nome:Identificador> "(" <param:Parametro> ")" <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: vec![param],
            tipo_retorno: None,
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
    // Sintaxe 5: Tipo no início, com um parâmetro
    "funcao" <retorno:Tipo> <nome:Identificador> "(" <param:Parametro> ")" <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: vec![param],
            tipo_retorno: Some(retorno),
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
};

// Sintaxe 2: Com dois parâmetros, sem tipo de retorno
FuncaoComDoisParams: DeclaracaoFuncao = {
    "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> ")" <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: vec![param1, param2],
            tipo_retorno: None,
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
    // Sintaxe 5: Tipo no início, com dois parâmetros
    "funcao" <retorno:Tipo> <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> ")" <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: vec![param1, param2],
            tipo_retorno: Some(retorno),
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
};

// Sintaxe com três parâmetros
FuncaoComTresParams: DeclaracaoFuncao = {
    "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> ")" <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: vec![param1, param2, param3],
            tipo_retorno: None,
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
    "funcao" <retorno:Tipo> <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> ")" <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: vec![param1, param2, param3],
            tipo_retorno: Some(retorno),
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
};

// Sintaxe 3: Sem parâmetros, tipo no final com =>
FuncaoComSeta: DeclaracaoFuncao = {
    "funcao" <nome:Identificador> "(" ")" "=>" <retorno:Tipo> <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: Vec::new(),
            tipo_retorno: Some(retorno),
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
};

// Sintaxe 4: Com um parâmetro, tipo no final com =>
FuncaoComSetaUmParam: DeclaracaoFuncao = {
    "funcao" <nome:Identificador> "(" <param:Parametro> ")" "=>" <retorno:Tipo> <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: vec![param],
            tipo_retorno: Some(retorno),
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
};

// Sintaxe 4: Com dois parâmetros, tipo no final com =>
FuncaoComSetaDoisParams: DeclaracaoFuncao = {
    "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> ")" "=>" <retorno:Tipo> <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: vec![param1, param2],
            tipo_retorno: Some(retorno),
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
};

// Sintaxe com três parâmetros e =>
FuncaoComSetaTresParams: DeclaracaoFuncao = {
    "funcao" <nome:Identificador> "(" <param1:Parametro> "," <param2:Parametro> "," <param3:Parametro> ")" "=>" <retorno:Tipo> <corpo:Bloco> => {
        DeclaracaoFuncao {
            nome,
            parametros: vec![param1, param2, param3],
            tipo_retorno: Some(retorno),
            modificador: ModificadorAcesso::Publico,
            corpo: match corpo {
                Comando::Bloco(comandos) => comandos,
                cmd => vec![cmd],
            },
        }
    },
};

Parametro: Parametro = {
    <tipo:Tipo> <nome:Identificador> => {
        Parametro {
            nome,
            tipo,
            valor_padrao: None,
        }
    },
};

Tipo: Tipo = {
    "inteiro" => Tipo::Inteiro,
    "texto" => Tipo::Texto,
    "booleano" => Tipo::Booleano,
    "vazio" => Tipo::Vazio,
    <nome:Identificador> => Tipo::Classe(nome),
};

pub Expressao: Expressao = {
    ExpressaoComparacao,
};

ExpressaoComparacao: Expressao = {
    ExpressaoAritmetica,
    <esq:ExpressaoAritmetica> "==" <dir:ExpressaoAritmetica> => 
        Expressao::Comparacao(OperadorComparacao::Igual, Box::new(esq), Box::new(dir)),
    <esq:ExpressaoAritmetica> "!=" <dir:ExpressaoAritmetica> => 
        Expressao::Comparacao(OperadorComparacao::Diferente, Box::new(esq), Box::new(dir)),
    <esq:ExpressaoAritmetica> ">" <dir:ExpressaoAritmetica> => 
        Expressao::Comparacao(OperadorComparacao::MaiorQue, Box::new(esq), Box::new(dir)),
    <esq:ExpressaoAritmetica> "<" <dir:ExpressaoAritmetica> => 
        Expressao::Comparacao(OperadorComparacao::Menor, Box::new(esq), Box::new(dir)),
};

ExpressaoAritmetica: Expressao = {
    ExpressaoMultiplicacao,
    <esq:ExpressaoMultiplicacao> "+" <dir:ExpressaoMultiplicacao> => 
        Expressao::Aritmetica(OperadorAritmetico::Soma, Box::new(esq), Box::new(dir)),
    <esq:ExpressaoMultiplicacao> "-" <dir:ExpressaoMultiplicacao> => 
        Expressao::Aritmetica(OperadorAritmetico::Subtracao, Box::new(esq), Box::new(dir)),
};

ExpressaoMultiplicacao: Expressao = {
    ExpressaoPrimaria,
    <esq:ExpressaoPrimaria> "*" <dir:ExpressaoPrimaria> => 
        Expressao::Aritmetica(OperadorAritmetico::Multiplicacao, Box::new(esq), Box::new(dir)),
    <esq:ExpressaoPrimaria> "/" <dir:ExpressaoPrimaria> => 
        Expressao::Aritmetica(OperadorAritmetico::Divisao, Box::new(esq), Box::new(dir)),
    <esq:ExpressaoPrimaria> "%" <dir:ExpressaoPrimaria> => 
        Expressao::Aritmetica(OperadorAritmetico::Modulo, Box::new(esq), Box::new(dir)),
};

ExpressaoPrimaria: Expressao = {
    <n:NumeroLiteral> => Expressao::Inteiro(n),
    <s:StringLiteral> => Expressao::Texto(s),
    "verdadeiro" => Expressao::Booleano(true),
    "falso" => Expressao::Booleano(false),
    <id:Identificador> => Expressao::Identificador(id),
    "(" <expr:Expressao> ")" => expr,
    <funcao:Identificador> "(" ")" => 
        Expressao::Chamada(funcao, vec![]),
    <funcao:Identificador> "(" <arg:Expressao> ")" => 
        Expressao::Chamada(funcao, vec![arg]),
    <funcao:Identificador> "(" <arg1:Expressao> "," <arg2:Expressao> ")" => 
        Expressao::Chamada(funcao, vec![arg1, arg2]),
    <funcao:Identificador> "(" <arg1:Expressao> "," <arg2:Expressao> "," <arg3:Expressao> ")" => 
        Expressao::Chamada(funcao, vec![arg1, arg2, arg3]),
};

Identificador: String = <id:TIdentificador> => id;
NumeroLiteral: i64 = <n:TInteiro> => n;
StringLiteral: String = <s:TString> => s;

extern {
    type Location = usize;
    type Error = String;
    
    enum Token {
        "se" => Token::TSe,
        "então" => Token::TEntao,
        "senão" => Token::TSenao,
        "enquanto" => Token::TEnquanto,
        "funcao" => Token::TFuncao,
        "retorne" => Token::TRetorne,
        "imprima" => Token::TImprima,
        "inteiro" => Token::TTipoInteiro,
        "texto" => Token::TTipoTexto,
        "booleano" => Token::TTipoBooleano,
        "vazio" => Token::TTipoVazio,
        "verdadeiro" => Token::TVerdadeiro,
        "falso" => Token::TFalso,
        "=" => Token::TAtribuicao,
        "==" => Token::TIgual,
        "!=" => Token::TDiferente,
        ">" => Token::TMaiorQue,
        "<" => Token::TMenor,
        "+" => Token::TMais,
        "-" => Token::TMenos,
        "*" => Token::TMultiplicacao,
        "/" => Token::TDivisao,
        "%" => Token::TModulo,
        "(" => Token::TParenEsq,
        ")" => Token::TParenDir,
        "{" => Token::TChaveEsq,
        "}" => Token::TChaveDir,
        ";" => Token::TPontoVirgula,
        "," => Token::TVirgula,
        "=>" => Token::TSeta,
        TString => Token::TString(<String>),
        TIdentificador => Token::TIdentificador(<String>),
        TInteiro => Token::TInteiro(<i64>),
    }
}